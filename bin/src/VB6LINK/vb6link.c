/*
	VB6LINK source code
	Copyright (c) 2006-2025, Vladimir Kamenar.
	All rights reserved.

	This tool is a wrapper for the Microsoft linker distributed with Visual Basic 6.
	The purpose of the wrapper is to link native Visual Basic 6 executables to 32-bit
	DLL, especially when using non-stdcall calling conventions (e.g. cdecl), by
	injecting import libraries generated by the ImpLib SDK into the Microsoft linker
	command line.

	How to install the wrapper:
	---------------------------

	1. Copy VB6LINK.EXE to the Visual Basic 6 installation directory. It's typically
	      \Program Files\Microsoft Visual Studio\VB98\       (in Win32)
	         or
	      \Program Files (x86)\Microsoft Visual Studio\VB98\ (in Win64)
	2. Rename the Microsoft linker LINK.EXE to LNK.EXE
	3. Rename the wrapper VB6LINK.EXE to LINK.EXE

	How to unistall the wrapper:
	----------------------------

	Just remove the wrapper and rename LNK.EXE back to LINK.EXE.

	How to use the wrapper:
	-----------------------

	Place the import libraries generated by the ImpLib SDK into the same directory where
	the Visual Basic 6 project files are located. For each import library create a
	module with the same name as the DLL. For example, for OPENAL32.DLL the import lib
	will be OPENAL32.LIB (this file is generated by the ImpLib SDK) and the module file
	will be OPENAL32.BAS (this file must be created by the developer). Both OPENAL32.LIB
	and OPENAL32.BAS must be placed in the project directory.

	The module file must contain a dummy implementation for each of the DLL functions,
	including the correct parameters.

	The wrapper substitutes the object file generated by the C2 compiler with the import
	library file having the same name, if any. For example, OPENAL32.BAS is compiled to
	OPENAL32.OBJ. Then, the wrapper substitutes OPENAL32.OBJ with OPENAL32.LIB to let
	the final executable link to OPENAL32.DLL.
*/

#define WINDOWS_IGNORE_PACKING_MISMATCH // workaroud for C2118 in W10 SDK
#include <windows.h>

// Error messages defined as arrays of char to avoid the \0
char err0[] = { '-','E','R','R',':',' ','V','i','s','u','a','l',' ','B','a','s','i','c',' ','6',' ','n','o','t',' ','i','n','s','t','a','l','l','e','d' };
char err1[] = { '-','E','R','R',':',' ','V','B','6','.','E','X','E',' ','p','a','t','h',' ','n','o','t',' ','f','o','u','n','d' } ;
char err2[] = { '-','E','R','R',':',' ','L','N','K','.','E','X','E',' ','n','o','t',' ','f','o','u','n','d' };
char err3[] = { '-','E','R','R',':',' ','E','r','r','o','r',' ','r','u','n','n','i','n','g',' ','L','N','K','.','E','X','E' };

char pmem[2080], buf[2047], copy_LNK;

// A simple memcpy replacement if linking without CRT
void cmemcpy(char *dest, char *src, int n){
	for(int i = 0; i < n; i++)
		dest[i] = src[i];
}

int ep(void){
STARTUPINFO sinfo;
PROCESS_INFORMATION pinfo;
HKEY regKey;
HANDLE hOut = GetStdHandle(STD_OUTPUT_HANDLE);
char *cur, *start, *dst, *bk;
unsigned int tmp, stage, quote;

	// STDOUT might be unavailable (this should never happen when linking from the command line or the IDE)
	if(hOut == INVALID_HANDLE_VALUE)
		hOut = 0;

	if(GetFileAttributes("LNK.EXE") == INVALID_FILE_ATTRIBUTES){
		// LNK.EXE not found. Maybe MSDEV is running the linker in the sources directory.
		// Let's try to copy LNK.EXE from the installation directory.
		if(RegOpenKeyEx(HKEY_CLASSES_ROOT, "VisualBasic.Project\\shell\\open\\command", 0, KEY_QUERY_VALUE, &regKey) != ERROR_SUCCESS){
			if(hOut)
				WriteFile(hOut, err0, sizeof(err0), &tmp, 0); // VB6 not installed
			return -1;
		}
		stage = sizeof(buf);
		tmp = RegQueryValueEx(regKey, "", 0, 0, buf, &stage);
		RegCloseKey(regKey);
		if(tmp != ERROR_SUCCESS){
			if(hOut)
				WriteFile(hOut, err1, sizeof(err1), &tmp, 0); // VB6 path not found
			return -1;
		}
		start = buf + stage;
		while(start > buf && *start != '\\')
			start--;
		cur = buf;
		if(*cur == '"')
			cur++;
		*(int*)start = 'KNL\\';
		*(int*)(start + 4) = 'EXE.';
		*(start + 8) = 0;
		if(!CopyFile(cur, "LNK.EXE", 0)){
			if(hOut)
				WriteFile(hOut, err2, sizeof(err2), &tmp, 0); // LNK.EXE not found
			return -1;
		}
		copy_LNK = 1;
	}
	start = cur = GetCommandLine();
	*((int*)pmem) = 'KNL';
	dst = pmem + 3;
	stage = quote = 0;

	// Parse the command line
	while(*cur){
		if(stage){
			if(*cur == '"')
				quote ^= 1;
			else{
				if(!quote && *cur == ' '){
					cmemcpy(dst, start, (tmp = ++cur - start));
					dst += tmp;
					start = cur;
					continue;
				}
				if((*((int*)cur) | 0x20202020) == 'jbo.'){
					cmemcpy(buf, start, (tmp = cur + 1 - start));
					*((unsigned int*)(buf + tmp)) = 'bil';
					bk = buf;
					while(*bk <= '"')
						bk++;
					cur += 4;
					if(GetFileAttributes(bk) != INVALID_FILE_ATTRIBUTES){
						tmp += 3;
						start = buf;
					}else
						tmp = cur - start;
					cmemcpy(dst, start, tmp);
					dst += tmp;
					start = cur;
					continue;
				}
			}
		}else if((*((unsigned int*)cur) | 0x20202020) == 'knil'){
			cur += 4;
			if((*((unsigned int*)cur) | 0x20202020) == 'exe.')
				cur += 4;
			if(*cur != ' ')
				continue;
			stage = 1;
			start = cur;
		}
		cur++;
	}
	cmemcpy(dst, start, (tmp = cur - start));
	dst += tmp;
	*((int*)dst) = 'PO/ ';
	*((int*)(dst + 4)) = 'ON:T';
	*((int*)(dst + 8)) = 'FER';
	tmp = 0;

	// Run the real linker
	GetStartupInfo(&sinfo);
	if(CreateProcess(0, pmem, 0, 0, 1, 0, 0, 0, &sinfo, &pinfo)){
		CloseHandle(pinfo.hThread);
		WaitForSingleObject(pinfo.hProcess, INFINITE);
		GetExitCodeProcess(pinfo.hProcess, &tmp);
		CloseHandle(pinfo.hProcess);
	}else{
		if(hOut)
			WriteFile(hOut, err3, sizeof(err3), &tmp, 0); // Couldn't launch the linker
		tmp = -1;
	}
	return tmp;
}

// Program entry point
void start(void){
int cnt, err = ep();
	if(copy_LNK)
		for(cnt = 0; cnt < 5 && !DeleteFile("LNK.EXE"); cnt++) // Try to delete LNK.EXE (only if we did copy this file)
			Sleep(128);
	ExitProcess(err);
}
