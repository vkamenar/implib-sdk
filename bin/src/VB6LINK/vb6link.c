/*
	VB6LINK source code
	Copyright (c) 2006-2025, Vladimir Kamenar.
	All rights reserved.

	This tool is a wrapper for the Microsoft linker distributed with Visual Basic 6.
	The purpose of the wrapper is to link native Visual Basic 6 executables to 32-bit
	DLL, especially when using non-stdcall calling conventions (e.g. cdecl), by
	injecting import libraries generated by the ImpLib SDK into the Microsoft linker
	command line.

	How to install the wrapper:
	---------------------------

	1. Copy VB6LINK.EXE to the Visual Basic 6 installation directory.
	   The path is typically \Program Files\Microsoft Visual Studio\VB98\ (in Win32) or
	   \Program Files (x86)\Microsoft Visual Studio\VB98\ (in Win64).
	2. Rename the Microsoft linker LINK.EXE to LNK.EXE.
	3. Rename the wrapper VB6LINK.EXE to LINK.EXE.

	How to unistall the wrapper:
	----------------------------

	Just remove the wrapper and rename LNK.EXE back to LINK.EXE.

	How to use the wrapper:
	-----------------------

	Place the import libraries generated by the ImpLib SDK into the same directory where
	the Visual Basic 6 project files are located. For each import library create a
	module with the same name as the DLL. For example, for OPENAL32.DLL the import lib
	will be OPENAL32.LIB (this file is generated by the ImpLib SDK) and the module file
	will be OPENAL32.BAS (this file must be created by the developer). Both OPENAL32.LIB
	and OPENAL32.BAS must be placed in the project directory.

	The module file must contain a dummy implementation for each of the DLL functions,
	including the correct parameters.

	The wrapper substitutes the object file generated by the C2 compiler with the import
	library file having the same name, if any. For example, OPENAL32.BAS is compiled to
	OPENAL32.OBJ. Then, the wrapper substitutes OPENAL32.OBJ with OPENAL32.LIB to let
	the final executable link to OPENAL32.DLL.
*/

#define WINDOWS_IGNORE_PACKING_MISMATCH /* workaroud for C2118 in W10 SDK */
#include <windows.h>

/* Error messages */
char err0[] = "-ERR: Visual Basic 6 not installed";
char err1[] = "-ERR: VB6.EXE path not found";
char err2[] = "-ERR: LNK.EXE not found";
char err3[] = "-ERR: Not enough heap memory";
char err4[] = "-ERR: Error spawning LNK.EXE";

char buf[2048];
WIN32_FIND_DATA fdata;
int copy_LNK;

/* A simple memcpy replacement if linking without CRT */
void cmemcpy(char *dest, char *src, int n){
	for(int i = 0; i < n; i++)
		dest[i] = src[i];
}

int ep(void){
STARTUPINFO sinfo;
PROCESS_INFORMATION pinfo;
HKEY regKey;
HANDLE hFind, hOut = GetStdHandle(STD_OUTPUT_HANDLE);
void* pMem;
char *cur, *start, *dst, *bk;
unsigned int stage, tmp, quote;
	hFind = FindFirstFile("LNK.EXE", &fdata);
	if(hFind != INVALID_HANDLE_VALUE)
		FindClose(hFind);
	else{
		/* LNK.EXE not found. Maybe MSDEV has spawned linker in the sources directory.
		   Let's try to copy LNK.EXE to the same directory. */
		if(RegOpenKeyEx(HKEY_CLASSES_ROOT, "VisualBasic.Project\\shell\\open\\command",
			0, KEY_QUERY_VALUE, &regKey) != ERROR_SUCCESS){
			WriteFile(hOut, err0, sizeof(err0) - 1, &stage, 0); // VB6 not installed
			return -1;
		}
		stage = sizeof(buf) - 1;
		tmp = RegQueryValueEx(regKey, "", 0, 0, buf, &stage);
		RegCloseKey(regKey);
		if(tmp != ERROR_SUCCESS){
			WriteFile(hOut, err1, sizeof(err1) - 1, &stage, 0); // VB6 path not found
			return -1;
		}
		start = buf + stage;
		while(start > buf && *start != '\\')
			start--;
		cur = buf;
		if(*cur == '"')
			cur++;
		*(unsigned int*)start = 'KNL\\';
		*(unsigned int*)(start + 4) = 'EXE.';
		*(start + 8) = 0;
		if(!CopyFile(cur, "LNK.EXE", 0)){
			WriteFile(hOut, err2, sizeof(err2) - 1, &stage, 0); // LNK.EXE not found
			return -1;
		}
		copy_LNK++;
	}
	start = cur = GetCommandLine();
	pMem = HeapAlloc(GetProcessHeap(), 0, strlen(cur) + 16);
	if(!pMem){
		WriteFile(hOut, err3, sizeof(err3) - 1, &stage, 0); // Not enough heap memory
		return -1;
	}
	*((unsigned int*)pMem) = 'KNL';
	dst = (char*)pMem + 3;
	stage = quote = 0;

	// Parse the command line
	while(*cur){
		if(stage){
			if(*cur == '"')
				quote ^= 1;
			else{
				if(!quote && *cur == ' '){
					cmemcpy(dst, start, (tmp = ++cur - start));
					dst += tmp;
					start = cur;
					continue;
				}
				if((*((unsigned int*)cur) | 0x20202020) == 'jbo.'){
					cmemcpy(buf, start, (tmp = cur + 1 - start));
					*((unsigned int*)(buf + tmp)) = 'bil';
					bk = buf;
					while(*bk <= '"')
						bk++;
					cur += 4;
					if((hFind = FindFirstFile(bk, &fdata)) != INVALID_HANDLE_VALUE){
						FindClose(hFind);
						tmp += 3;
						start = buf;
					}else
						tmp = cur - start;
					cmemcpy(dst, start, tmp);
					dst += tmp;
					start = cur;
					continue;
				}
			}
		}else if((*((unsigned int*)cur) | 0x20202020) == 'knil'){
			cur += 4;
			if((*((unsigned int*)cur) | 0x20202020) == 'exe.')
				cur += 4;
			if(*cur != ' ')
				continue;
			stage = 1;
			start = cur;
		}
		cur++;
	}
	cmemcpy(dst, start, (tmp = cur - start));
	dst += tmp;
	*((unsigned int*)dst) = 'PO/ ';
	*((unsigned int*)(dst + 4)) = 'ON:T';
	*((unsigned int*)(dst + 8)) = 'FER';
	stage = 0;

	// Run the real linker
	GetStartupInfo(&sinfo);
	if(CreateProcess(0, pMem, 0, 0, 1, 0, 0, 0, &sinfo, &pinfo)){
		CloseHandle(pinfo.hThread);
		WaitForSingleObject(pinfo.hProcess, INFINITE);
		GetExitCodeProcess(pinfo.hProcess, &stage);
		CloseHandle(pinfo.hProcess);
	}else{
		WriteFile(hOut, err4, sizeof(err4) - 1, &stage, 0); // Couldn't spawn the linker
		stage = -1;
	}
	HeapFree(GetProcessHeap(), 0, pMem);
	return stage;
}

// Program entry point
void start(void){
int cnt, err = ep();
	if(copy_LNK)
		for(cnt = 0; cnt < 7 && !DeleteFile("LNK.EXE"); cnt++) // Try to delete LNK.EXE
			Sleep(128);
	ExitProcess(err);
}
